% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ebnm.R, R/ebnm_ash.R, R/ebnm_normal.R,
%   R/ebnm_point_laplace.R, R/ebnm_point_normal.R, R/output.R
\name{ebnm}
\alias{ebnm}
\alias{ebnm_ash}
\alias{ebnm_normal}
\alias{ebnm_point_laplace}
\alias{ebnm_point_normal}
\alias{output_default}
\alias{output_all}
\title{Solve the EBNM problem}
\usage{
ebnm(x, s = 1, mode = 0, scale = "estimate", g_init = NULL,
  fix_g = FALSE, output = output_default(),
  prior_type = c("point_normal", "normal", "point_laplace", "ash"), ...)

ebnm_ash(x, s = 1, mode = 0, scale = "estimate", g_init = NULL,
  fix_g = FALSE, output = output_default(), ...)

ebnm_normal(x, s = 1, mode = 0, scale = "estimate", g_init = NULL,
  fix_g = FALSE, output = output_default())

ebnm_point_laplace(x, s = 1, mode = 0, scale = "estimate",
  g_init = NULL, fix_g = FALSE, output = output_default())

ebnm_point_normal(x, s = 1, mode = 0, scale = "estimate",
  g_init = NULL, fix_g = FALSE, output = output_default(),
  control = NULL)

output_default()

output_all()
}
\arguments{
\item{x}{A vector of observations.}

\item{s}{A vector of standard deviations (or a scalar if all are equal).}

\item{mode}{The location of the mode for the class of priors. Set to
"estimate" to estimate it from the data.}

\item{scale}{Fixes the scale of the prior. Corresponds to the standard
deviation of the normal component for normal and point-normal
distributions; the rate parameter of the Laplace component for
point-Laplace distributions; and parameter \code{mixsd} for adaptive
shrinkage priors. Set to "estimate" to estimate it from the data.}

\item{g_init}{The prior distribution. Usually this is left unspecified and
estimated from the data. However, it can be used in conjuction with
\code{fix_g = TRUE} to fix the prior (useful, for example, to do
computations with the "true" \code{g}). If \code{g_init} is specified but
\code{fix_g = FALSE}, \code{g_init} specifies the initial value of \code{g}
used during optimization.}

\item{fix_g}{If \code{TRUE}, fix \code{g} at the specified value instead of
estimating it.}

\item{output}{A character vector indicating which values are to be returned.
Options include:
  \describe{
    \item{\code{"result"}}{Summary results (posterior means
      \eqn{E \theta_j} and posterior values of \eqn{E \theta_j^2}).}
    \item{\code{"fitted_g"}}{The fitted prior (a list with elements
      \code{pi0}, \code{a}, and \code{mu}).}
    \item{\code{"lfsr"}}{A vector of local false sign rates.}
    \item{\code{"loglik"}}{The optimal log likelihood attained.}
    \item{\code{"post_sampler"}}{A function that can be used to produce
      samples from the posterior. It takes a single parameter
      \code{nsamp}, the number of posterior samples to return per
      observation.}
   }}

\item{prior_type}{The type of prior to estimate. See "Details" below.}

\item{control}{A list of control parameters to be passed to \code{optim}.}
}
\description{
Solves the Empirical Bayes Normal Means problem using a specified class of
  priors.
}
\details{
TODO: update me.

Given vectors of data \code{x} and standard errors \code{s},
  solve the EBNM problem with a point-normal or point-laplace prior. The
  model is \deqn{x_j \sim N(\theta_j, s_j^2),} where \eqn{s_j} are given and
  \eqn{\theta_j \sim g}, with \eqn{g} either a mixture of a point mass at
  \eqn{\mu} and a normal distribution: \deqn{\theta_j \sim \pi_0 \delta_\mu
  + (1 - \pi_0)N(\mu, 1/a)} or a mixture of a point mass at zero and a
  laplace distribution: \deqn{\theta_j \sim \pi_0 \delta_0 +
  (1 - \pi_0)DExp(a).} \eqn{\pi_0}, \eqn{a}, and \eqn{\mu} are estimated by
  marginal maximum likelihood.
}
\section{Functions}{
\itemize{
\item \code{ebnm_ash}: Solves the EBNM problem using an ash prior.

\item \code{ebnm_normal}: Solves the EBNM problem using a normal prior.

\item \code{ebnm_point_laplace}: Solves the EBNM problem using a point-laplace prior.

\item \code{ebnm_point_normal}: Solves the EBNM problem using a point-normal prior.

\item \code{output_default}: Defines the default return values.

\item \code{output_all}: Lists all valid return values.
}}

\examples{
theta <- c(rep(0, 1000), rexp(1000)) # means
s <- rgamma(2000, 1, 1) # standard errors
x <- theta + rnorm(2000, 0, s) # observations
x.ebnm <- ebnm_point_normal(x, s)
pm <- x.ebnm$result$posterior_mean

}
