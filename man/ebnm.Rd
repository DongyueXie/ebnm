% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ebnm.R, R/ebnm_fns.R, R/output.R
\name{ebnm}
\alias{ebnm}
\alias{ebnm_point_normal}
\alias{ebnm_point_laplace}
\alias{ebnm_normal}
\alias{ebnm_normal_scale_mixture}
\alias{ebnm_unimodal}
\alias{ebnm_unimodal_symmetric}
\alias{ebnm_unimodal_nonnegative}
\alias{ebnm_unimodal_nonpositive}
\alias{ebnm_ash}
\alias{output_default}
\alias{output_all}
\title{Solve the EBNM problem}
\usage{
ebnm(x, s = 1, mode = 0, scale = "estimate", g_init = NULL,
  fix_g = FALSE, output = output_default(), control = NULL,
  prior_type = c("point_normal", "point_laplace", "normal",
  "normal_scale_mixture", "unimodal", "unimodal_symmetric",
  "unimodal_nonnegative", "unimodal_nonpositive", "ash"), ...)

ebnm_point_normal(x, s = 1, mode = 0, scale = "estimate",
  g_init = NULL, fix_g = FALSE, output = output_default(),
  control = NULL)

ebnm_point_laplace(x, s = 1, mode = 0, scale = "estimate",
  g_init = NULL, fix_g = FALSE, output = output_default(),
  control = NULL)

ebnm_normal(x, s = 1, mode = 0, scale = "estimate", g_init = NULL,
  fix_g = FALSE, output = output_default(), control = NULL)

ebnm_normal_scale_mixture(x, s = 1, mode = 0, scale = "estimate",
  g_init = NULL, fix_g = FALSE, output = output_default(),
  control = NULL)

ebnm_unimodal(x, s = 1, mode = 0, scale = "estimate",
  g_init = NULL, fix_g = FALSE, output = output_default(),
  control = NULL, ...)

ebnm_unimodal_symmetric(x, s = 1, mode = 0, scale = "estimate",
  g_init = NULL, fix_g = FALSE, output = output_default(),
  control = NULL, ...)

ebnm_unimodal_nonnegative(x, s = 1, mode = 0, scale = "estimate",
  g_init = NULL, fix_g = FALSE, output = output_default(),
  control = NULL, ...)

ebnm_unimodal_nonpositive(x, s = 1, mode = 0, scale = "estimate",
  g_init = NULL, fix_g = FALSE, output = output_default(),
  control = NULL, ...)

ebnm_ash(x, s = 1, mode = 0, scale = "estimate", g_init = NULL,
  fix_g = FALSE, output = output_default(), control = NULL, ...)

output_default()

output_all()
}
\arguments{
\item{x}{A vector of observations.}

\item{s}{A vector of standard errors (or a scalar if all are equal).
Standard errors can be infinite, but they must be nonzero.}

\item{mode}{Scalar specifying the mode of the prior, g. Set to \code{"estimate"}
to estimate it from the data.}

\item{scale}{Scalar or vector, specifying the scale parameter(s) of the prior. The
precise interpretation of \code{scale} depends on \code{prior_type}. For \code{prior_type=normal, point_normal}
it is a scalar specifying the standard deviation of the normal component;
for \code{prior_type=point_laplace} it is a scalar specifying the rate parameter of the
Laplace component; for other prior types, which are implemented using the \code{\link[ashr]{ash}} function in the
\code{ashr} package,
it is a vector specifying the parameter \code{mixsd} to be passed to \code{\link[ashr]{ash}}.
Set to \code{"estimate"} to estimate it from the data (or to use the default \code{mixsd} in \code{\link[ashr]{ash}}).}

\item{g_init}{The prior distribution, \eqn{g}. Usually this is left unspecified (NULL) and
estimated from the data. However, it can be used in conjuction with
\code{fix_g = TRUE} to fix the prior (useful, for example, to do
computations with the "true" \code{g} in simulations). If \code{g_init} is specified but
\code{fix_g = FALSE}, \code{g_init} specifies the initial value of \code{g}
used during optimization, but this has the side effect of fixing the
\code{mode} and \code{scale} parameters for adaptive shrinkage (ash) priors.}

\item{fix_g}{If \code{TRUE}, fix the prior \eqn{g}=\code{g_init} instead of
estimating it.}

\item{output}{A character vector indicating which values are to be returned.
Options include:
  \describe{
    \item{\code{"result"}}{Summary results (posterior first and second
      moments).}
    \item{\code{"fitted_g"}}{The fitted prior \eqn{\hat{g}}.}
    \item{\code{"loglik"}}{The optimal log likelihood attained, \eqn{L(\hat{g}}.}
    \item{\code{"lfsr"}}{A vector of local false sign rates.}
    \item{\code{"post_sampler"}}{A function that can be used to produce
      samples from the posterior. It takes a single parameter
      \code{nsamp}, the number of posterior samples to return per
      observation.}
   }}

\item{control}{A list of control parameters to be passed to the optimization
function (\code{nlm} for normal, point-normal, and point-Laplace priors
and, unless specified otherwise, \code{mixsqp::mixsqp} for ash priors).}

\item{prior_type}{The prior family \eqn{G}. See "Details" below.}

\item{...}{Additional parameters. \code{unimodal_} prior types pass these
parameters to \code{ashr::ash}.}
}
\description{
Solves the empirical Bayes normal means problem using a specified family of
  priors.
}
\details{
TODO: update me.

Given vectors of data \code{x} and standard errors \code{s},
  solve the "empirical Bayes normal means" (EBNM) problem, for various
  choices of prior family.
  The model is \deqn{x_j | \theta_j, s_j \sim N(\theta_j, s_j^2),}  and
  \deqn{\theta_j | s_j \sim g \in G}, where the distribution \eqn{g} is to be estimated.
  The distribution \eqn{g} is often referred to as the "prior distribution" for \eqn{\theta_j}
  and \eqn{G} is a specified family of prior distributions (several options for \eqn{G} are implemented, some
  parametric and others non-parametric;  see below for examples).

  Solving the EBNM problem involves
  two steps. First, estimate \eqn{g \in  G}, by maximum marginal likelihood, yielding
  an estimate \deqn{\hat{g}:= \arg\max_{g \in G} L(g)} where
  \deqn{L(g):= \prod_j
  \int p(x_j | \theta_j, s_j)  g(d\theta_j);}
  Second, compute the posterior distributions \eqn{p(\theta_j | x_j, s_j, \hat{g})}, and/or summaries
  such as the posterior means and posterior second moments, etc.
}
\section{Functions}{
\itemize{
\item \code{ebnm_point_normal}: Solves the EBNM problem using a point-normal prior.

\item \code{ebnm_point_laplace}: Solves the EBNM problem using a point-Laplace prior.

\item \code{ebnm_normal}: Solves the EBNM problem using a normal prior (with no
point mass).

\item \code{ebnm_normal_scale_mixture}: Solves the EBNM problem using a scale mixture of normals.

\item \code{ebnm_unimodal}: Solves the EBNM problem using a unimodal distribution.

\item \code{ebnm_unimodal_symmetric}: Solves the EBNM problem using a symmetric unimodal
distribution.

\item \code{ebnm_unimodal_nonnegative}: Solves the EBNM problem using a unimodal distribution with
support constrained to be greater than the mode.

\item \code{ebnm_unimodal_nonpositive}: Solves the EBNM problem using a unimodal distribution with
support constrained to be less than the mode.

\item \code{ebnm_ash}: A generic function for solving the EBNM problem using an
adaptive shrinkage (ash) prior.

\item \code{output_default}: Defines the default return values.

\item \code{output_all}: Lists all valid return values.
}}

\examples{
theta <- c(rep(0, 1000), rexp(1000)) # means
s <- rgamma(2000, 1, 1) # standard errors
x <- theta + rnorm(2000, 0, s) # observations
x.ebnm <- ebnm_point_normal(x, s)
pm <- x.ebnm$result$posterior_mean

}
