% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ebnm_point_normal.R
\name{ebnm_normal}
\alias{ebnm_normal}
\title{Solve the EBNM problem with normal prior}
\usage{
ebnm_normal(x, s = 1, norm = mean(s), output = c("result", "fitted_g",
  "loglik"), control = NULL)
}
\arguments{
\item{x}{A vector of observations.}

\item{s}{A vector of standard deviations (or a scalar if all are
equal).}

\item{norm}{The normalization factor to divide \code{x} and \code{s}
by before running optimization (this should not affect results, but
it improves numerical stability when \code{x} and \code{s} are
tiny).}

\item{output}{A vector of strings indicating which values are to be
returned. Options include:
\describe{
  \item{"result"}{Summary results (posterior means \eqn{E \theta_j}
    and posterior values of \eqn{E \theta_j^2}).}
  \item{"fitted_g"}{The fitted prior (a list with elements \code{pi0}
    and \code{a}).}
  \item{"loglik"}{The optimal log likelihood attained.}
  \item{"post_sampler"}{A function that can be used to produce
    samples from the posterior. It takes a single parameter
    \code{nsamp}, the number of posterior samples to return per
    observation.}
 }}

\item{control}{A list of control parameters to be passed to
\code{optim}.}
}
\value{
A list with elements specified by parameter \code{output}.
}
\description{
This function solves the Empirical Bayes Normal Means
  problem with a normal prior.
}
\details{
Given vectors of data \code{x} and standard errors \code{s},
  solve the EBNM problem with a normal prior. The model is
  \deqn{x_j \sim N(\theta_j, s_j^2),} where \eqn{s_j} are given
  and \deqn{\theta_j \sim N(0, 1/a).} \eqn{a} is estimated by
  marginal maximum likelihood.
}
\examples{
mu = c(rep(0, 1000), rexp(1000)) # means
s = rgamma(2000, 1, 1) #standard errors
x = mu + rnorm(2000, 0, s) # observations
x.ebnm = ebnm_point_normal(x, s)
ashr::get_pm(x.ebnm) # posterior mean

}
